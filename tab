package com.yourpkg;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

import java.time.LocalDateTime;
import java.util.*;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.*;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class SchedulerEmailNotifTest {

    @Mock private ChangesHistoryRepo changesHistoryRepo;
    @Mock private RefVersionsCopyStatusRepo refVersionsCopyStatusRepo;
    @Mock private RefWorkspaceRepo refWorkspaceRepo;
    @Mock private EmailService emailService;
    @Mock private MailProperties mailProperties;

    @InjectMocks
    private SchedulerEmailNotif schedulerEmailNotif;

    @Test
    void execute_buildsNotifEmailDto_withExpectedFields() throws Exception {
        // GIVEN
        String referentialName = "RISK_LIMIT_REFERENTIAL";
        String workspaceName   = "WS1";
        Long   versionId       = 1L;

        RefWorkspace ws = new RefWorkspace();
        ws.setWorkspace(workspaceName);

        RefVersionsCopyStatus status = new RefVersionsCopyStatus();
        status.setWorkspace(workspaceName);
        status.setVersion(versionId);

        // repos
        when(refVersionsCopyStatusRepo
                .findByReferentialNameAndCopyStatusAndCopyTimestampGreaterThanEqualAndCopyTimestampLessThan(
                        eq(referentialName), any(), any(), any()))
            .thenReturn(List.of(status));

        when(refWorkspaceRepo.findByWorkspace(workspaceName)).thenReturn(ws);

        // history → contenu JSON VALIDE avec la clé utilisée dans buildNotifEmail:
        // currentContentRoot.get("setOfLimit").get("riskLimitReferentialFamily")
        ChangesHistory ch = new ChangesHistory();
        ch.setAction(RefInputActionEnum.UPDATE.name());
        ch.setVersion(versionId);
        ch.setWorkspace(workspaceName);
        ch.setInputBy("tester");
        ch.setInputTimestamp(LocalDateTime.now());
        ch.setContent("{\"setOfLimit\":{\"riskLimitReferentialFamily\":\"FamilleTest\"}}");
        ch.setOriginContent("{\"before\":\"x\"}");
        when(changesHistoryRepo
                .findByObjectAndWorkspaceAndVersionInAndInputTimestampGreaterThanEqualAndInputTimestampLessThan(
                        eq(referentialName), eq(ws), anySet(), any(), any()))
            .thenReturn(List.of(ch));

        // capturer la liste envoyée à l'email service
        @SuppressWarnings("unchecked")
        ArgumentCaptor<List<NotifEmailDto>> listCaptor = ArgumentCaptor.forClass(List.class);

        // WHEN
        schedulerEmailNotif.executeTaskSxEmailNotif();

        // THEN
        verify(emailService, atLeastOnce()).apply(eq(emailService), eq(mailProperties), listCaptor.capture());
        List<NotifEmailDto> payload = listCaptor.getValue();
        assertThat(payload).hasSize(1);

        NotifEmailDto dto = payload.get(0);
        assertThat(dto.getReferentialName()).isEqualTo("FamilleTest");         // extrait du JSON
        assertThat(dto.getWorkspace()).isEqualTo(workspaceName);
        assertThat(dto.getAction()).isEqualTo(RefInputActionEnum.UPDATE.name());
        assertThat(dto.getVersion()).isEqualTo(versionId);
        assertThat(dto.getInputBy()).isEqualTo("tester");
        assertThat(dto.getPublishDate()).isNotNull();

        // le diff n’est pas généré pour CREATE; pour UPDATE on attend un diff non null (ta méthode appelle JsonUtils.processJsonDiff)
        assertThat(dto.getContentDiff()).isNotNull();
    }
